
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Polygon module &#8212; Atlas 0.1 documentation</title>
    <link rel="stylesheet" href="static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="static/alabaster.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="static/documentation_options.js"></script>
    <script src="static/jquery.js"></script>
    <script src="static/underscore.js"></script>
    <script src="static/doctools.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Region module" href="Region.html" />
    <link rel="prev" title="Point module" href="Point.html" />
   
  <link rel="stylesheet" href="static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="module-Polygon">
<span id="polygon-module"></span><h1>Polygon module<a class="headerlink" href="#module-Polygon" title="Permalink to this headline">¶</a></h1>
<dl class="py class">
<dt id="Polygon.Polygon">
<em class="property">class </em><code class="sig-prename descclassname">Polygon.</code><code class="sig-name descname">Polygon</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">vertices</span></em>, <em class="sig-param"><span class="n">reorder</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#Polygon.Polygon" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>This class represents a polygon as a list of vertex points ordered in clockwise order.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vertices</strong><span class="classifier">List of Point</span></dt><dd><p>Store the vertices in a clockwise list</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#Polygon.Polygon.area" title="Polygon.Polygon.area"><code class="xref py py-obj docutils literal notranslate"><span class="pre">area</span></code></a>()</p></td>
<td><p>Finds the area of the polygon</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#Polygon.Polygon.cut" title="Polygon.Polygon.cut"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cut</span></code></a>(p1, p2)</p></td>
<td><p>Cuts a polygon along two points</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#Polygon.Polygon.cut_gap" title="Polygon.Polygon.cut_gap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cut_gap</span></code></a>(p1, p2, gap)</p></td>
<td><p>Cuts a polygon along two points</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#Polygon.Polygon.cut_out" title="Polygon.Polygon.cut_out"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cut_out</span></code></a>(interior_polygon)</p></td>
<td><p>Cuts a larger polygon into parts without an interior polygon part</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#Polygon.Polygon.cut_out_2" title="Polygon.Polygon.cut_out_2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cut_out_2</span></code></a>(interior_polygon)</p></td>
<td><p>Cuts out a shape from a larger polygon if the interior polygon is a scaled down version of the larger polygon</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#Polygon.Polygon.cut_out_gap_2" title="Polygon.Polygon.cut_out_gap_2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cut_out_gap_2</span></code></a>(interior_polygon, scalar)</p></td>
<td><p>Cuts out a shape from a larger polygon if the interior polygon is a scaled down version of the larger polygon with a gap</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#Polygon.Polygon.easy_cut" title="Polygon.Polygon.easy_cut"><code class="xref py py-obj docutils literal notranslate"><span class="pre">easy_cut</span></code></a>(p, ang, gap)</p></td>
<td><p>Cuts a polygon into two parts based on a point and an angle, with a gap for the width of the cut</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#Polygon.Polygon.find_ext_point" title="Polygon.Polygon.find_ext_point"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_ext_point</span></code></a>(furthest_point, ang, initial_p)</p></td>
<td><p>Find an extreme point given a furthest_point, an angle, and an initial point</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#Polygon.Polygon.find_intersecting_edge" title="Polygon.Polygon.find_intersecting_edge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_intersecting_edge</span></code></a>(p, ang)</p></td>
<td><p>Given a line segment this method returns an edge that that line segment intersects</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#Polygon.Polygon.find_intersecting_edges" title="Polygon.Polygon.find_intersecting_edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_intersecting_edges</span></code></a>(p, ext_p)</p></td>
<td><p>Given a line segment this method returns edges that that line segment intersects, this is used because of an edge case in the find_intersecting_edges</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#Polygon.Polygon.furthest_conglomerate_point" title="Polygon.Polygon.furthest_conglomerate_point"><code class="xref py py-obj docutils literal notranslate"><span class="pre">furthest_conglomerate_point</span></code></a>(p)</p></td>
<td><p>Finds a point that has the furthest x value among all points in the polygon and has the furthest y value among all points in the polygon</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#Polygon.Polygon.furthest_point" title="Polygon.Polygon.furthest_point"><code class="xref py py-obj docutils literal notranslate"><span class="pre">furthest_point</span></code></a>(point)</p></td>
<td><p>Finds the furthest point in this polygon from a give point</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#Polygon.Polygon.get_center" title="Polygon.Polygon.get_center"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_center</span></code></a>()</p></td>
<td><p>Finds the centroid of the polygon.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#Polygon.Polygon.get_perimeter" title="Polygon.Polygon.get_perimeter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_perimeter</span></code></a>()</p></td>
<td><p>Finds the perimeter of the polygon</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#Polygon.Polygon.get_vertices" title="Polygon.Polygon.get_vertices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_vertices</span></code></a>()</p></td>
<td><p>Gets the vertices of the polygon</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#Polygon.Polygon.in_segment" title="Polygon.Polygon.in_segment"><code class="xref py py-obj docutils literal notranslate"><span class="pre">in_segment</span></code></a>(p1, p2, p3)</p></td>
<td><p>Returns true if p3 is in the line segment from p1 to p2.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#Polygon.Polygon.inside" title="Polygon.Polygon.inside"><code class="xref py py-obj docutils literal notranslate"><span class="pre">inside</span></code></a>(larger_polygon)</p></td>
<td><p>Checks a given polygon to see if it is in a larger polygon</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#Polygon.Polygon.intersection" title="Polygon.Polygon.intersection"><code class="xref py py-obj docutils literal notranslate"><span class="pre">intersection</span></code></a>(p1, p2, p3, p4)</p></td>
<td><p>Finds the point of intersection given twp line segments</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#Polygon.Polygon.is_bordering" title="Polygon.Polygon.is_bordering"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_bordering</span></code></a>(other)</p></td>
<td><p>Checks to see if a given polygon borders this polygon.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#Polygon.Polygon.is_contained" title="Polygon.Polygon.is_contained"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_contained</span></code></a>(point)</p></td>
<td><p>Returns true if Point point is located on the edge of or in this Polygon.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#Polygon.Polygon.is_convex" title="Polygon.Polygon.is_convex"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_convex</span></code></a>()</p></td>
<td><p>Returns true if the polygon is convex and has no intersecting lines.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#Polygon.Polygon.is_rectangle" title="Polygon.Polygon.is_rectangle"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_rectangle</span></code></a>()</p></td>
<td><p>Check a given polygon to see if it is a rectangle</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#Polygon.Polygon.longest_side_and_length" title="Polygon.Polygon.longest_side_and_length"><code class="xref py py-obj docutils literal notranslate"><span class="pre">longest_side_and_length</span></code></a>()</p></td>
<td><p>Finds the longest side and length</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#Polygon.Polygon.move_center_to" title="Polygon.Polygon.move_center_to"><code class="xref py py-obj docutils literal notranslate"><span class="pre">move_center_to</span></code></a>(p)</p></td>
<td><p>Moves a polygon’s center to a given point p</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#Polygon.Polygon.move_polygon_by_center" title="Polygon.Polygon.move_polygon_by_center"><code class="xref py py-obj docutils literal notranslate"><span class="pre">move_polygon_by_center</span></code></a>(left_right_distance, …)</p></td>
<td><p>Moves a polygon’s center by left_right_distance left or right, and up_down_distance up or down.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#Polygon.Polygon.on_edge" title="Polygon.Polygon.on_edge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">on_edge</span></code></a>(p)</p></td>
<td><p>Checks to see if a given point p is on any edge of the polygon</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#Polygon.Polygon.rectangle_inside" title="Polygon.Polygon.rectangle_inside"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rectangle_inside</span></code></a>(p1, p2)</p></td>
<td><p>Finds a rectangle given an edge of the polygon</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#Polygon.Polygon.scale_of_polygon" title="Polygon.Polygon.scale_of_polygon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scale_of_polygon</span></code></a>(scalar)</p></td>
<td><p>Scales a polygon by a scalar and returns a new scaled polygon centered on the original polygon’s center</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#Polygon.Polygon.set_vertices" title="Polygon.Polygon.set_vertices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_vertices</span></code></a>(vertices[, reorder])</p></td>
<td><p>Sets the vertices of the polygon</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#Polygon.Polygon.split" title="Polygon.Polygon.split"><code class="xref py py-obj docutils literal notranslate"><span class="pre">split</span></code></a>(p, ang, gap)</p></td>
<td><p>splits a polygon along a point and an angle relative to edge of p</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#Polygon.Polygon.to_points" title="Polygon.Polygon.to_points"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_points</span></code></a>(polygons)</p></td>
<td><p>Takes a list of polygons and converts it to a list of points</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#Polygon.Polygon.to_polygon" title="Polygon.Polygon.to_polygon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_polygon</span></code></a>(vertices)</p></td>
<td><p>Returns a polygon given a list of lists, i.e. [[1, 2], [3, 4], [5, 6]] =&gt; polygon with those vertices.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="Polygon.Polygon.area">
<code class="sig-name descname">area</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Polygon.Polygon.area" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the area of the polygon</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>float</dt><dd><p>The area of the polygon</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="Polygon.Polygon.cut">
<code class="sig-name descname">cut</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">p1</span></em>, <em class="sig-param"><span class="n">p2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#Polygon.Polygon.cut" title="Permalink to this definition">¶</a></dt>
<dd><p>Cuts a polygon along two points</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>p1</strong><span class="classifier">Point</span></dt><dd><p>First Point</p>
</dd>
<dt><strong>p2</strong><span class="classifier">Point</span></dt><dd><p>Second Point</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>List of Polygons</dt><dd><p>Two new polygons formed by the cut</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="Polygon.Polygon.cut_gap">
<code class="sig-name descname">cut_gap</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">p1</span></em>, <em class="sig-param"><span class="n">p2</span></em>, <em class="sig-param"><span class="n">gap</span></em><span class="sig-paren">)</span><a class="headerlink" href="#Polygon.Polygon.cut_gap" title="Permalink to this definition">¶</a></dt>
<dd><p>Cuts a polygon along two points</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>p1</strong><span class="classifier">Point</span></dt><dd><p>First Point</p>
</dd>
<dt><strong>p2</strong><span class="classifier">Point</span></dt><dd><p>Second Point</p>
</dd>
<dt><strong>gap</strong><span class="classifier">float</span></dt><dd><p>width of the cut</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>List of Polygons</dt><dd><p>Two new polygons formed by the cut</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="Polygon.Polygon.cut_out">
<code class="sig-name descname">cut_out</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">interior_polygon</span></em><span class="sig-paren">)</span><a class="headerlink" href="#Polygon.Polygon.cut_out" title="Permalink to this definition">¶</a></dt>
<dd><p>Cuts a larger polygon into parts without an interior polygon part</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>interior_polygon</strong><span class="classifier">Polygon</span></dt><dd><p>The polygon to cut out</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>list of Polygons</dt><dd><p>the parts of the original polygon without the interior polygon</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="Polygon.Polygon.cut_out_2">
<code class="sig-name descname">cut_out_2</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">interior_polygon</span></em><span class="sig-paren">)</span><a class="headerlink" href="#Polygon.Polygon.cut_out_2" title="Permalink to this definition">¶</a></dt>
<dd><p>Cuts out a shape from a larger polygon if the interior polygon is a scaled down version of the larger polygon</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>interior_polygon</strong><span class="classifier">Polygon</span></dt><dd><p>the scaled down version of the larger polygon to cut out</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>list of Polygons</dt><dd><p>the cut out parts on the exterior of the larger polygon</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="Polygon.Polygon.cut_out_gap_2">
<code class="sig-name descname">cut_out_gap_2</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">interior_polygon</span></em>, <em class="sig-param"><span class="n">scalar</span></em><span class="sig-paren">)</span><a class="headerlink" href="#Polygon.Polygon.cut_out_gap_2" title="Permalink to this definition">¶</a></dt>
<dd><p>Cuts out a shape from a larger polygon if the interior polygon is a scaled down version of the larger polygon
with a gap</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>interior_polygon</strong><span class="classifier">Polygon</span></dt><dd><p>the scaled down version of the larger polygon to cut out</p>
</dd>
<dt><strong>scalar</strong><span class="classifier">float</span></dt><dd><p>the scalar to put on the interior polygon to make the gap</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>list of Polygons</dt><dd><p>the cut out parts on the exterior of the larger polygon</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="Polygon.Polygon.easy_cut">
<code class="sig-name descname">easy_cut</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">p</span></em>, <em class="sig-param"><span class="n">ang</span></em>, <em class="sig-param"><span class="n">gap</span></em><span class="sig-paren">)</span><a class="headerlink" href="#Polygon.Polygon.easy_cut" title="Permalink to this definition">¶</a></dt>
<dd><p>Cuts a polygon into two parts based on a point and an angle, with a gap for the width of the cut</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>p</strong><span class="classifier">Point</span></dt><dd><p>The point to cut from</p>
</dd>
<dt><strong>ang</strong><span class="classifier">float</span></dt><dd><p>The angle to cut on (in radians)</p>
</dd>
<dt><strong>gap</strong><span class="classifier">float</span></dt><dd><p>The cut width</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>list of Polygons</dt><dd><p>The two cut parts of the polygon</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="Polygon.Polygon.find_ext_point">
<em class="property">static </em><code class="sig-name descname">find_ext_point</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">furthest_point</span></em>, <em class="sig-param"><span class="n">ang</span></em>, <em class="sig-param"><span class="n">initial_p</span></em><span class="sig-paren">)</span><a class="headerlink" href="#Polygon.Polygon.find_ext_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Find an extreme point given a furthest_point, an angle, and an initial point</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>furthest_point</strong><span class="classifier">Point</span></dt><dd><p>the furthest point for reference to find an extreme point</p>
</dd>
<dt><strong>ang</strong><span class="classifier">float</span></dt><dd><p>the angle towards the extreme point</p>
</dd>
<dt><strong>initial_p</strong><span class="classifier">Point</span></dt><dd><p>the initial point for the line towards the extreme point</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Point</dt><dd><p>the extreme point</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="Polygon.Polygon.find_intersecting_edge">
<code class="sig-name descname">find_intersecting_edge</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">p</span></em>, <em class="sig-param"><span class="n">ang</span></em><span class="sig-paren">)</span><a class="headerlink" href="#Polygon.Polygon.find_intersecting_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a line segment this method returns an edge that that line segment intersects</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>p</strong><span class="classifier">point</span></dt><dd><p>the first point of the line segment</p>
</dd>
<dt><strong>ang</strong><span class="classifier">float</span></dt><dd><p>the angle in radians that the ray from <cite>p</cite> extends from</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>list of Points</dt><dd><p>the edge on the polygon that the line segment crosses</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="Polygon.Polygon.find_intersecting_edges">
<code class="sig-name descname">find_intersecting_edges</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">p</span></em>, <em class="sig-param"><span class="n">ext_p</span></em><span class="sig-paren">)</span><a class="headerlink" href="#Polygon.Polygon.find_intersecting_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a line segment this method returns edges that that line segment intersects, this is used because of an
edge case in the find_intersecting_edges</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>p</strong><span class="classifier">point</span></dt><dd><p>the first point of the line segment</p>
</dd>
<dt><strong>ext_p</strong><span class="classifier">Point</span></dt><dd><p>the second point of the line segment</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>list of list of points</dt><dd><p>the edge on the polygon that the line segment crosses</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="Polygon.Polygon.furthest_conglomerate_point">
<code class="sig-name descname">furthest_conglomerate_point</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">p</span></em><span class="sig-paren">)</span><a class="headerlink" href="#Polygon.Polygon.furthest_conglomerate_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds a point that has the furthest x value among all points in the polygon and has the furthest y value among
all points in the polygon</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>p</strong><span class="classifier">Point</span></dt><dd><p>the point to find the furthest point from</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="Polygon.Polygon.furthest_point">
<code class="sig-name descname">furthest_point</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">point</span></em><span class="sig-paren">)</span><a class="headerlink" href="#Polygon.Polygon.furthest_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the furthest point in this polygon from a give point</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>point</strong><span class="classifier">Point</span></dt><dd><p>The point to compare for every polygon vertices</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Point</dt><dd><p>The furthest point from the given point in the polygon</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="Polygon.Polygon.get_center">
<code class="sig-name descname">get_center</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Polygon.Polygon.get_center" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the centroid of the polygon.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>Point</dt><dd><p>Point representing the centroid of the polygon</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>We are using the general formula for a centroid, expressed below.</p>
<div class="math notranslate nohighlight">
\[\begin{split}C_x = \frac{1}{6A} \sum_{i=0}^{n-1}\left(\left(x_i + x_{i+1}\right) \times
\left(x_1 y_{i+1} - x_{i+1} y_i \right) \right) \\
C_y = \frac{1}{6A} \sum_{i=0}^{n-1}\left(\left(y_i + y_{i+1}\right) \times
\left(x_1 y_{i+1} - x_{i+1} y_i \right) \right)\end{split}\]</div>
<p>Where <cite>A</cite> is defined as the area using the shoelace method.</p>
<div class="math notranslate nohighlight">
\[A = \frac{1}{2} \sum_{i=0}^{n-1}\left(x_i y_{i+1} - x_{i+1} y_i\right)\]</div>
<p>More information can be found <a class="reference external" href="https://en.wikipedia.org/wiki/Centroid#Of_a_polygon">here</a>.</p>
</dd></dl>

<dl class="py method">
<dt id="Polygon.Polygon.get_perimeter">
<code class="sig-name descname">get_perimeter</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Polygon.Polygon.get_perimeter" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the perimeter of the polygon</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>float</dt><dd><p>The perimeter of the polygon</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="Polygon.Polygon.get_vertices">
<code class="sig-name descname">get_vertices</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Polygon.Polygon.get_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the vertices of the polygon</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>List of Points</dt><dd><p>The vertices</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="Polygon.Polygon.in_segment">
<em class="property">static </em><code class="sig-name descname">in_segment</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">p1</span></em>, <em class="sig-param"><span class="n">p2</span></em>, <em class="sig-param"><span class="n">p3</span></em><span class="sig-paren">)</span><a class="headerlink" href="#Polygon.Polygon.in_segment" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if p3 is in the line segment from p1 to p2.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>p1</strong><span class="classifier">Point</span></dt><dd><p>First point of the line segment</p>
</dd>
<dt><strong>p2</strong><span class="classifier">Point</span></dt><dd><p>Second point of the line segment</p>
</dd>
<dt><strong>p3</strong><span class="classifier">Point</span></dt><dd><p>The point to see if it is in the line segment</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>bool</dt><dd><p>True if p3 is in the line segment from p1 to p2</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>After checking for vertical and horizontal lines, we know that the <cite>p3</cite> is only on the line segment between
<cite>p1</cite> and <cite>p2</cite> if the distance from <cite>p1</cite> to <cite>p2</cite> thorough <cite>p3</cite> is the same as the distance from <cite>p1</cite> directly
to <cite>p2</cite>.</p>
<p>This method is only accurate to approximately eight decimal places, after which internal rounding can affect the
result.
&gt;&gt;&gt; print(Polygon.in_segment(Point(0, 0), Point(5, 5), Point(1, 1.00000001)))
True</p>
<p>Example of an incorrect, but very close test.</p>
</dd></dl>

<dl class="py method">
<dt id="Polygon.Polygon.inside">
<code class="sig-name descname">inside</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">larger_polygon</span></em><span class="sig-paren">)</span><a class="headerlink" href="#Polygon.Polygon.inside" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks a given polygon to see if it is in a larger polygon</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>larger_polygon</strong><span class="classifier">Polygon</span></dt><dd><p>The larger polygon that could contain the given polygon</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>bool</dt><dd><p>True if the given polygon is in larger_polygon</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="Polygon.Polygon.intersection">
<em class="property">static </em><code class="sig-name descname">intersection</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">p1</span></em>, <em class="sig-param"><span class="n">p2</span></em>, <em class="sig-param"><span class="n">p3</span></em>, <em class="sig-param"><span class="n">p4</span></em><span class="sig-paren">)</span><a class="headerlink" href="#Polygon.Polygon.intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the point of intersection given twp line segments</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>p1</strong><span class="classifier">Point</span></dt><dd><p>The first point in the first line segment</p>
</dd>
<dt><strong>p2</strong><span class="classifier">Point</span></dt><dd><p>The second point in the first line segment</p>
</dd>
<dt><strong>p3</strong><span class="classifier">Point</span></dt><dd><p>The first point in the second line segment</p>
</dd>
<dt><strong>p4</strong><span class="classifier">Point</span></dt><dd><p>The second point in the second line segment</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Point</dt><dd><p>The intersection</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="Polygon.Polygon.is_bordering">
<code class="sig-name descname">is_bordering</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#Polygon.Polygon.is_bordering" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks to see if a given polygon borders this polygon.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Polygon</span></dt><dd><p>The polygon we need to check for a border</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>bool</dt><dd><p>True if the two share and edge, false otherwise.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>I have not been able to find a way to do this in less than <span class="math notranslate nohighlight">\(O(n^2)\)</span> complexity, which is acceptable
so long as we do not compare every polygon to every other polygon in the city. That will tank performance.</p>
<p>This will not catch intersecting polygons unless one vertex sits on an edge of the other.</p>
</dd></dl>

<dl class="py method">
<dt id="Polygon.Polygon.is_contained">
<code class="sig-name descname">is_contained</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">point</span></em><span class="sig-paren">)</span><a class="headerlink" href="#Polygon.Polygon.is_contained" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if Point point is located on the edge of or in this Polygon.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>point</strong><span class="classifier">Point</span></dt><dd><p>The point to check if in this polygon</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>bool</dt><dd><p>True if contained in the polygon</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This method utilises the Ray-casting algorithm. A horizontal ray from point increasing to infinity will
intersect with the polygon an odd number of times if it is located inside the polygon and an even number of
times if point is located outside the polygon.</p>
<p>You can find more information about the algorithm here: <a class="reference external" href="https://rosettacode.org/wiki/Ray-casting_algorithm">https://rosettacode.org/wiki/Ray-casting_algorithm</a></p>
</dd></dl>

<dl class="py method">
<dt id="Polygon.Polygon.is_convex">
<code class="sig-name descname">is_convex</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Polygon.Polygon.is_convex" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if the polygon is convex and has no intersecting lines.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>bool</dt><dd><p>Returns true if the polygon is convex and has no intersecting lines, or false if not.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This method will return false if the number of vertices in the polygon is less than 3 or if any of the vertices
repeat.</p>
</dd></dl>

<dl class="py method">
<dt id="Polygon.Polygon.is_rectangle">
<code class="sig-name descname">is_rectangle</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Polygon.Polygon.is_rectangle" title="Permalink to this definition">¶</a></dt>
<dd><p>Check a given polygon to see if it is a rectangle</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>bool</dt><dd><p>True if the polygon is a rectangle</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="Polygon.Polygon.longest_side_and_length">
<code class="sig-name descname">longest_side_and_length</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Polygon.Polygon.longest_side_and_length" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the longest side and length</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>list</dt><dd><p>A list where the first element is the longest distance, the the next two elements are the points on the edge</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="Polygon.Polygon.move_center_to">
<code class="sig-name descname">move_center_to</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">p</span></em><span class="sig-paren">)</span><a class="headerlink" href="#Polygon.Polygon.move_center_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Moves a polygon’s center to a given point p</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>p</strong><span class="classifier">Point</span></dt><dd><p>The new center for the polygon</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="Polygon.Polygon.move_polygon_by_center">
<code class="sig-name descname">move_polygon_by_center</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">left_right_distance</span></em>, <em class="sig-param"><span class="n">up_down_distance</span></em><span class="sig-paren">)</span><a class="headerlink" href="#Polygon.Polygon.move_polygon_by_center" title="Permalink to this definition">¶</a></dt>
<dd><p>Moves a polygon’s center by left_right_distance left or right, and up_down_distance up or down.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>left_right_distance</strong><span class="classifier">float</span></dt><dd><p>the distance to move the center of the polygon by left or right</p>
</dd>
<dt><strong>up_down_distance</strong><span class="classifier">float</span></dt><dd><p>the distance to move the center of the polygon by up or down</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="Polygon.Polygon.on_edge">
<code class="sig-name descname">on_edge</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">p</span></em><span class="sig-paren">)</span><a class="headerlink" href="#Polygon.Polygon.on_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks to see if a given point p is on any edge of the polygon</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>p</strong><span class="classifier">Point</span></dt><dd><p>The point to check to see if it is on any edge of the polygon</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>bool</dt><dd><p>True if p is on any edge of the polygon</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="Polygon.Polygon.rectangle_inside">
<code class="sig-name descname">rectangle_inside</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">p1</span></em>, <em class="sig-param"><span class="n">p2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#Polygon.Polygon.rectangle_inside" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds a rectangle given an edge of the polygon</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>p1</strong><span class="classifier">Point</span></dt><dd><p>one edge vertices</p>
</dd>
<dt><strong>p2</strong><span class="classifier">Point</span></dt><dd><p>second edge vertices</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Polygon</dt><dd><p>The rectangle inside the polygon</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="Polygon.Polygon.scale_of_polygon">
<code class="sig-name descname">scale_of_polygon</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">scalar</span></em><span class="sig-paren">)</span><a class="headerlink" href="#Polygon.Polygon.scale_of_polygon" title="Permalink to this definition">¶</a></dt>
<dd><p>Scales a polygon by a scalar and returns a new scaled polygon centered on the original polygon’s center</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>scalar</strong><span class="classifier">float</span></dt><dd><p>The scalar to scale the polygon by (could be positive or negative for shrink or grow)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Polygon</dt><dd><p>The new scaled polygon centered on the original polygon’s center</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="Polygon.Polygon.set_vertices">
<code class="sig-name descname">set_vertices</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">vertices</span></em>, <em class="sig-param"><span class="n">reorder</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#Polygon.Polygon.set_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the vertices of the polygon</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vertices</strong><span class="classifier">List of points</span></dt><dd><p>The new vertices</p>
</dd>
<dt><strong>reorder</strong><span class="classifier">bool</span></dt><dd><p>If ture, reorder the vertices into clockwise order</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="Polygon.Polygon.split">
<code class="sig-name descname">split</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">p</span></em>, <em class="sig-param"><span class="n">ang</span></em>, <em class="sig-param"><span class="n">gap</span></em><span class="sig-paren">)</span><a class="headerlink" href="#Polygon.Polygon.split" title="Permalink to this definition">¶</a></dt>
<dd><p>splits a polygon along a point and an angle relative to edge of p</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>p</strong><span class="classifier">Point</span></dt><dd><p>The starting point of the cut</p>
</dd>
<dt><strong>ang</strong><span class="classifier">float</span></dt><dd><p>The angle of the line to cut down in radians</p>
</dd>
<dt><strong>gap</strong><span class="classifier">float</span></dt><dd><p>width of the cut between the split polygon</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>List of Polygons</dt><dd><p>A list of polygons from the resulting split</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="Polygon.Polygon.to_points">
<em class="property">static </em><code class="sig-name descname">to_points</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">polygons</span></em><span class="sig-paren">)</span><a class="headerlink" href="#Polygon.Polygon.to_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of polygons and converts it to a list of points</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>polygons</strong><span class="classifier">List of Polygons</span></dt><dd><p>list of Polygons</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>List of Points</dt><dd><p>List of all vertices in the list of Polygons</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="Polygon.Polygon.to_polygon">
<em class="property">static </em><code class="sig-name descname">to_polygon</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">vertices</span></em><span class="sig-paren">)</span><a class="headerlink" href="#Polygon.Polygon.to_polygon" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a polygon given a list of lists, i.e. [[1, 2], [3, 4], [5, 6]] =&gt; polygon with those vertices</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vertices</strong><span class="classifier">list of lists</span></dt><dd><p>the vertices of the polygon in the form of a list of lists</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="Polygon.clockwise_order">
<code class="sig-prename descclassname">Polygon.</code><code class="sig-name descname">clockwise_order</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">vertices</span></em><span class="sig-paren">)</span><a class="headerlink" href="#Polygon.clockwise_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a list of vertices, return them ordered in clockwise order</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vertices</strong><span class="classifier">List</span></dt><dd><p>The vertices of a polygon</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>List</dt><dd><p>The vertices ordered in clockwise order.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="Polygon.print_list">
<code class="sig-prename descclassname">Polygon.</code><code class="sig-name descname">print_list</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">list_name</span></em>, <em class="sig-param"><span class="n">points</span></em><span class="sig-paren">)</span><a class="headerlink" href="#Polygon.print_list" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Atlas</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Constructor.html">Constructor module</a></li>
<li class="toctree-l1"><a class="reference internal" href="District.html">District module</a></li>
<li class="toctree-l1"><a class="reference internal" href="Infrastructure.html">Infrastructure module</a></li>
<li class="toctree-l1"><a class="reference internal" href="Menu.html">Menu module</a></li>
<li class="toctree-l1"><a class="reference internal" href="Pathfinder.html">Pathfinder module</a></li>
<li class="toctree-l1"><a class="reference internal" href="Point.html">Point module</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Polygon module</a></li>
<li class="toctree-l1"><a class="reference internal" href="Region.html">Region module</a></li>
<li class="toctree-l1"><a class="reference internal" href="Voronoi.html">Voronoi module</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="Point.html" title="previous chapter">Point module</a></li>
      <li>Next: <a href="Region.html" title="next chapter">Region module</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2021, Thomas Grifka, Max Jorgensen, Matt Schwennesen, Emma Smith, Joe Teahen.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.4.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="sources/Polygon.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>